{% extends "base.html" %}

{% block title %}Live Analysis - ReViision{% endblock %}

{% block styles %}
<style>
/* Analysis-specific styles using design system */
.video-feed-container {
    position: relative;
    background: var(--color-neutral-900);
    border-radius: var(--radius-xl);
    overflow: hidden;
    aspect-ratio: 16/9;
    min-height: 400px;
}

.video-feed {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.feed-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    height: 100%;
    color: var(--color-neutral-400);
    background: var(--color-neutral-800);
}

.feed-label {
    position: absolute;
    top: var(--spacing-3);
    left: var(--spacing-3);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: var(--spacing-1) var(--spacing-3);
    border-radius: var(--radius-full);
    font-size: var(--font-size-sm);
    font-weight: var(--font-weight-medium);
    z-index: 10;
}

.original-pip {
    position: absolute;
    top: var(--spacing-4);
    right: var(--spacing-4);
    width: 200px;
    height: 112px;
    border: 2px solid var(--color-primary-500);
    border-radius: var(--radius-lg);
    overflow: hidden;
    z-index: 20;
    background: var(--color-neutral-800);
}

.overlay-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
}

.control-panel {
    background: var(--color-surface-primary);
    border-radius: var(--radius-xl);
    padding: var(--spacing-6);
    box-shadow: var(--shadow-sm);
}

.overlay-controls {
    display: grid;
    gap: var(--spacing-4);
}

.overlay-toggle {
    display: flex;
    align-items: center;
    gap: var(--spacing-3);
    padding: var(--spacing-3);
    border-radius: var(--radius-lg);
    transition: var(--transition-all);
}

.overlay-toggle:hover {
    background: var(--color-surface-secondary);
}

.overlay-toggle input[type="radio"] {
    margin: 0;
}

.stats-panel {
    background: var(--color-surface-secondary);
    padding: var(--spacing-4);
    border-radius: var(--radius-lg);
    margin-bottom: var(--spacing-4);
}

@media (max-width: 767px) {
    .original-pip {
        width: 120px;
        height: 68px;
        top: var(--spacing-2);
        right: var(--spacing-2);
    }

    .video-feed-container {
        min-height: 250px;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="container py-6">
    <!-- Page Header -->
    <div class="mb-6">
        <h1 class="text-3xl font-bold text-primary mb-2">Live Camera Analysis</h1>
        <p class="text-secondary">Real-time computer vision analysis with customizable overlays</p>
    </div>

    <!-- Control Panel -->
    <div class="card mb-6">
        <div class="card-header">
            <h2 class="card-title">
                <i class="fas fa-sliders-h"></i>
                Camera Controls
            </h2>
        </div>
        <div class="card-body">
            <div class="d-flex flex-wrap gap-3 justify-between items-center">
                <div class="d-flex gap-3">
                    <button class="btn btn-primary" id="start-analysis">
                        <i class="fas fa-play"></i>
                        Start Analysis
                    </button>
                    <button class="btn btn-danger" id="stop-analysis" disabled>
                        <i class="fas fa-stop"></i>
                        Stop
                    </button>
                </div>
                <button class="btn btn-outline-secondary" id="restart-video" title="Restart Video Stream">
                    <i class="fas fa-redo"></i>
                    Restart Stream
                </button>
            </div>
        </div>
    </div>

    <!-- Video Feed -->
    <div class="card mb-6">
        <div class="card-header">
            <h3 class="card-title">
                <i class="fas fa-video"></i>
                Live Analysis Feed
            </h3>
        </div>
        <div class="card-body p-0">
            <div class="video-feed-container">
                <!-- Original feed (picture-in-picture) -->
                <div id="original-feed" class="original-pip">
                    <div class="feed-label">Original</div>
                    <div class="feed-placeholder">
                        <i class="fas fa-video fa-2x mb-2"></i>
                        <span class="text-sm">Original Feed</span>
                    </div>
                </div>

                <!-- Main analysis feed -->
                <div id="analysis-feed" class="feed-placeholder relative">
                    <div class="feed-label" id="active-overlay-label">Analysis View</div>
                    <div class="placeholder-content">
                    <i class="fas fa-eye fa-3x mb-3"></i>
                    <h5 class="text-xl font-semibold mb-2">Start Analysis to Begin</h5>
                    <p class="text-secondary">Analysis feed with overlays will appear here</p>
                </div>
                <div id="overlay-container" class="overlay-container"></div>
            </div>
        </div>
    </div>

    <!-- Controls Grid -->
    <div class="d-grid grid-cols-1 desktop-grid-cols-3 gap-6">
        <!-- Overlay Controls -->
        <div class="desktop-col-span-2">
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">
                        <i class="fas fa-layer-group"></i>
                        Overlay Controls
                    </h3>
                </div>
                <div class="card-body">
                    <div class="overlay-controls">
                        <div class="mb-6">
                            <h4 class="text-lg font-semibold mb-4">Visualization Overlays</h4>
                            <div class="d-grid grid-cols-1 tablet-grid-cols-2 gap-3">
                                <div class="form-check overlay-toggle">
                                    <input class="form-check-input" type="radio" name="overlay" id="none-overlay" value="none" checked>
                                    <label class="form-check-label font-medium" for="none-overlay">
                                        <i class="fas fa-eye-slash text-secondary mr-2"></i>
                                        None
                                    </label>
                                </div>
                                <div class="form-check overlay-toggle">
                                    <input class="form-check-input" type="radio" name="overlay" id="facial-overlay" value="facial">
                                    <label class="form-check-label font-medium" for="facial-overlay">
                                        <i class="fas fa-user-circle text-primary mr-2"></i>
                                        Facial Recognition
                                    </label>
                                </div>
                                <div class="form-check overlay-toggle">
                                    <input class="form-check-input" type="radio" name="overlay" id="heatmap-overlay" value="heatmap">
                                    <label class="form-check-label font-medium" for="heatmap-overlay">
                                        <i class="fas fa-fire text-danger mr-2"></i>
                                        Traffic Heatmap
                                    </label>
                                </div>
                                <div class="form-check overlay-toggle">
                                    <input class="form-check-input" type="radio" name="overlay" id="demographic-overlay" value="demographic">
                                    <label class="form-check-label font-medium" for="demographic-overlay">
                                        <i class="fas fa-users text-success mr-2"></i>
                                        Demographics
                                    </label>
                                </div>
                                <div class="form-check overlay-toggle">
                                    <input class="form-check-input" type="radio" name="overlay" id="dwell-overlay" value="dwell">
                                    <label class="form-check-label font-medium" for="dwell-overlay">
                                        <i class="fas fa-clock text-warning mr-2"></i>
                                        Dwell Time
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="mb-6">
                            <h4 class="text-lg font-semibold mb-4">Display Options</h4>
                            <div class="d-flex flex-wrap gap-4">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="show-bounding-boxes" checked>
                                    <label class="form-check-label font-medium" for="show-bounding-boxes">
                                        <i class="fas fa-square text-primary mr-2"></i>
                                        Bounding Boxes
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="show-labels" checked>
                                    <label class="form-check-label font-medium" for="show-labels">
                                        <i class="fas fa-tag text-success mr-2"></i>
                                        Labels
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="show-metrics" checked>
                                    <label class="form-check-label font-medium" for="show-metrics">
                                        <i class="fas fa-chart-bar text-info mr-2"></i>
                                        Metrics
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div id="overlay-specific-options">
                            <!-- Heatmap Options -->
                            <div id="heatmap-options" class="d-none">
                                <h4 class="text-lg font-semibold mb-4">Heatmap Options</h4>
                                <div class="mb-4">
                                    <div class="d-flex gap-4 mb-3">
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="heatmap-type" id="traffic-heatmap" checked>
                                            <label class="form-check-label font-medium" for="traffic-heatmap">Traffic Density</label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="heatmap-type" id="dwell-heatmap">
                                            <label class="form-check-label font-medium" for="dwell-heatmap">Dwell Time</label>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="heatmap-opacity" class="form-label">
                                            Opacity: <span id="opacity-value" class="font-semibold text-primary">15%</span>
                                        </label>
                                        <input type="range" class="form-control" min="5" max="50" value="15" id="heatmap-opacity">
                                    </div>
                                </div>
                            </div>

                            <!-- Facial Analysis Options -->
                            <div id="facial-options" class="d-none">
                                <h4 class="text-lg font-semibold mb-4">Facial Analysis Options</h4>
                                <div class="d-flex flex-wrap gap-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="show-age" checked>
                                        <label class="form-check-label font-medium" for="show-age">Age</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="show-gender" checked>
                                        <label class="form-check-label font-medium" for="show-gender">Gender</label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="show-emotion" checked>
                                        <label class="form-check-label font-medium" for="show-emotion">Emotion</label>
                                    </div>
                                </div>
                            </div>
                            <!-- Demographic Options -->
                            <div id="demographic-options" class="d-none">
                                <h4 class="text-lg font-semibold mb-4">Demographic Options</h4>
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle"></i>
                                    No additional options available for demographic overlay.
                                </div>
                            </div>

                            <!-- Dwell Time Options -->
                            <div id="dwell-options" class="d-none">
                                <h4 class="text-lg font-semibold mb-4">Dwell Time Options</h4>
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle"></i>
                                    No additional options available for dwell time overlay.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Statistics Panel -->
        <div class="card">
            <div class="card-header card-header-primary">
                <h3 class="card-title">
                    <i class="fas fa-chart-bar"></i>
                    Real-time Statistics
                </h3>
            </div>
            <div class="card-body">
                <div class="d-grid gap-4">
                    <div class="stats-panel">
                        <div class="d-flex justify-between items-center">
                            <span class="font-medium text-secondary">Current View:</span>
                            <span id="current-camera" class="font-semibold text-primary">Main Entrance</span>
                        </div>
                    </div>

                    <div class="stats-panel">
                        <div class="d-flex justify-between items-center mb-2">
                            <span class="font-medium text-secondary">People Detected:</span>
                            <span id="people-count" class="font-bold text-2xl text-primary">0</span>
                        </div>
                        <div class="d-flex justify-between items-center mb-2">
                            <span class="font-medium text-secondary">M/F Ratio:</span>
                            <span id="gender-ratio" class="font-semibold text-primary">0/0</span>
                        </div>
                        <div class="d-flex justify-between items-center">
                            <span class="font-medium text-secondary">Average Age:</span>
                            <span id="avg-age" class="font-semibold text-primary">--</span>
                        </div>
                    </div>

                    <div class="stats-panel">
                        <div class="d-flex justify-between items-center mb-2">
                            <span class="font-medium text-secondary">Current Traffic:</span>
                            <span id="current-traffic" class="font-semibold text-success">Low</span>
                        </div>
                        <div class="d-flex justify-between items-center">
                            <span class="font-medium text-secondary">Avg. Dwell Time:</span>
                            <span id="current-dwell-time" class="font-semibold text-primary">-- sec</span>
                        </div>
                    </div>

                    <div class="alert alert-primary">
                        <i class="fas fa-info-circle"></i>
                        Select different overlays to visualize various aspects of the vision analytics.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Historical Chart -->
    <div class="card mt-6">
        <div class="card-header card-header-success">
            <h3 class="card-title">
                <i class="fas fa-history"></i>
                Historical Data
            </h3>
        </div>
        <div class="card-body">
            <div class="chart-container" style="height: 300px;">
                <canvas id="historyChart"></canvas>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Global variables
    let analysisActive = false;
    let frameInterval = null;
    let abortController = null;
    let selectedOverlay = 'none';
    let detectedObjects = [];
    let movementHistory = [];
    let analysisDelay = 200; // milliseconds between frame processing
    
    // Enable debug mode to see dwell time logs
    window.DEBUG_MODE = true;
    
    // Initialize on document ready
    document.addEventListener('DOMContentLoaded', function() {
        // Set up event listeners
        document.getElementById('start-analysis').addEventListener('click', startAnalysis);
        document.getElementById('stop-analysis').addEventListener('click', stopAnalysis);
        document.getElementById('restart-video').addEventListener('click', restartVideoStream);
        
        // Overlay selection
        document.querySelectorAll('input[name="overlay"]').forEach(radio => {
            radio.addEventListener('change', function() {
                selectedOverlay = this.value;
                updateActiveOverlayLabel();
                updateOverlayOptions();
                
                if (analysisActive) {
                    updateAnalysisView();
                }
            });
        });
        
        // Heatmap opacity slider
        const opacitySlider = document.getElementById('heatmap-opacity');
        if (opacitySlider) {
            opacitySlider.addEventListener('input', function() {
                document.getElementById('opacity-value').textContent = this.value + '%';
                if (selectedOverlay === 'heatmap' && analysisActive) {
                    updateAnalysisView();
                }
            });
        }
        
        // Display option checkboxes
        document.querySelectorAll('.form-check-input').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                if (analysisActive) {
                    updateAnalysisView();
                }
            });
        });
        
        // Auto-start analysis by default
        setTimeout(() => {
            startAnalysis();
        }, 1000); // Small delay to ensure everything is initialized
    });
    
    function updateOverlayOptions() {
        // Hide all overlay-specific options
        document.getElementById('heatmap-options').style.display = 'none';
        document.getElementById('facial-options').style.display = 'none';
        document.getElementById('demographic-options').style.display = 'none';
        document.getElementById('dwell-options').style.display = 'none';
        
        // Show options for the selected overlay
        if (selectedOverlay === 'heatmap') {
            document.getElementById('heatmap-options').style.display = 'block';
        } else if (selectedOverlay === 'facial') {
            document.getElementById('facial-options').style.display = 'block';
        } else if (selectedOverlay === 'demographic') {
            document.getElementById('demographic-options').style.display = 'block';
        } else if (selectedOverlay === 'dwell') {
            document.getElementById('dwell-options').style.display = 'block';
        }
    }
    
    function updateActiveOverlayLabel() {
        const label = document.getElementById('active-overlay-label');
        if (!label) return;
        
        let overlayName = 'No Overlay';
        if (selectedOverlay === 'facial') overlayName = 'Facial Recognition';
        else if (selectedOverlay === 'heatmap') overlayName = 'Traffic Heatmap';

        else if (selectedOverlay === 'demographic') overlayName = 'Demographics';
        else if (selectedOverlay === 'dwell') overlayName = 'Dwell Time';
        
        label.textContent = overlayName;
    }
    
    function startAnalysis() {
        // Reset any previous analysis
        detectedObjects = [];
        movementHistory = [];
        
        // Update UI
        document.getElementById('start-analysis').disabled = true;
        document.getElementById('stop-analysis').disabled = false;
        
        // Set analysis active flag
        analysisActive = true;
        
        // Initialize video feeds
        resetFeedPlaceholders();
        initializeVideoFeeds();
        
        // Start frame capture loop
        captureVideoFrames();
        
        // Update the overlay label
        updateActiveOverlayLabel();
        
        // Show appropriate overlay controls
        updateOverlayOptions();
    }
    
    function stopAnalysis() {
        if (window.DEBUG_MODE) {
            console.log('Stopping analysis...');
        }
        
        // Set flag to false first to stop new operations
        analysisActive = false;
        
        // Cancel frame capture interval
        if (frameInterval) {
            clearInterval(frameInterval);
            frameInterval = null;
        }
        
        // Cancel any ongoing fetch requests
        if (abortController) {
            abortController.abort();
            abortController = null;
        }
        
        // Update UI
        document.getElementById('start-analysis').disabled = false;
        document.getElementById('stop-analysis').disabled = true;
        
        // Clear overlays
        const overlayContainer = document.getElementById('overlay-container');
        if (overlayContainer) {
            overlayContainer.innerHTML = '';
        }
        
        // Clear detected objects and movement history
        detectedObjects = [];
        movementHistory = [];
        
        // Reset feeds
        resetFeedPlaceholders();
        
        if (window.DEBUG_MODE) {
            console.log('Analysis stopped successfully');
        }
    }
    
    async function restartVideoStream() {
        if (window.DEBUG_MODE) {
            console.log('Restarting video stream...');
        }
        
        const restartBtn = document.getElementById('restart-video');
        const originalText = restartBtn.innerHTML;
        
        try {
            // Show loading state
            restartBtn.disabled = true;
            restartBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Restarting...';
            
            // Call the backend restart camera API
            const response = await fetch('/api/camera/restart', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                // Add timeout to prevent hanging
                signal: AbortSignal.timeout ? AbortSignal.timeout(30000) : undefined
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.status === 'success') {
                    // Restart was successful, reinitialize feeds if analysis is active
                    if (analysisActive) {
                        // Clear existing images first to force refresh
                        const existingImages = document.querySelectorAll('#original-feed-image, #analysis-feed-image');
                        existingImages.forEach(img => {
                            if (img.parentNode) {
                                img.parentNode.removeChild(img);
                            }
                        });
                        
                        // Small delay to ensure camera restart is complete, then reinitialize
                        setTimeout(() => {
                            initializeVideoFeeds();
                        }, 3000);  // Increased delay for more reliable restart
                    } else {
                        // If analysis is not active, still refresh the feeds for next start
                        setTimeout(() => {
                            resetFeedPlaceholders();
                        }, 1000);
                    }
                    
                    // Show success message briefly
                    restartBtn.innerHTML = '<i class="fas fa-check"></i> Restarted!';
                    restartBtn.className = 'btn btn-sm btn-success';
                    
                    setTimeout(() => {
                        restartBtn.innerHTML = originalText;
                        restartBtn.className = 'btn btn-sm btn-outline-warning';
                    }, 2000);
                    
                    if (window.DEBUG_MODE) {
                        console.log('Video stream restarted successfully:', result.message);
                    }
                } else {
                    console.error('Failed to restart camera:', result.message);
                    
                    // Show error state
                    restartBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Failed';
                    restartBtn.className = 'btn btn-sm btn-danger';
                    
                    // Show user-friendly error message
                    const errorMsg = result.message || 'Unknown error occurred';
                    alert(`Failed to restart camera: ${errorMsg}\n\nPlease check:\n- Camera configuration in Settings\n- Camera connection\n- System logs for details`);
                    
                    setTimeout(() => {
                        restartBtn.innerHTML = originalText;
                        restartBtn.className = 'btn btn-sm btn-outline-warning';
                    }, 3000);
                }
            } else {
                const errorText = `Server error (${response.status}): ${response.statusText}`;
                console.error('Camera restart API returned error:', response.status, response.statusText);
                
                // Show error state
                restartBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error';
                restartBtn.className = 'btn btn-sm btn-danger';
                
                alert(`Failed to restart camera: ${errorText}\n\nPlease check system logs and try again.`);
                
                setTimeout(() => {
                    restartBtn.innerHTML = originalText;
                    restartBtn.className = 'btn btn-sm btn-outline-warning';
                }, 3000);
            }
            
        } catch (error) {
            console.error('Error restarting video stream:', error);
            
            // Show error state
            restartBtn.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Error';
            restartBtn.className = 'btn btn-sm btn-danger';
            
            let errorMsg = 'Network error or timeout';
            if (error.name === 'TimeoutError') {
                errorMsg = 'Request timed out (camera may be busy)';
            } else if (error.name === 'TypeError') {
                errorMsg = 'Network connection error';
            }
            
            alert(`Error restarting video stream: ${errorMsg}\n\nPlease check:\n- Network connection\n- Camera availability\n- Try again in a few seconds`);
            
            setTimeout(() => {
                restartBtn.innerHTML = originalText;
                restartBtn.className = 'btn btn-sm btn-outline-warning';
            }, 3000);
        } finally {
            // Always re-enable button after delay
            setTimeout(() => {
                restartBtn.disabled = false;
            }, 1000);
        }
    }
    
    function initializeVideoFeeds() {
        const originalFeed = document.getElementById('original-feed');
        const analysisFeed = document.getElementById('analysis-feed');
        
        // Clear the feeds
        originalFeed.innerHTML = '';
        analysisFeed.innerHTML = '';
        
        // Show loading message
        originalFeed.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#666;">Loading video feed...</div>';
        analysisFeed.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#666;">Initializing analysis...</div>';
        
        // Create video feed image
        const feedImage = document.createElement('img');
        feedImage.id = 'original-feed-image';
        feedImage.style.width = '100%';
        feedImage.style.height = '100%';
        feedImage.style.objectFit = 'cover';
        
        // Set source to backend camera stream with cache-busting parameter
        const cacheBuster = Date.now();
        const streamUrl = `/camera_stream?t=${cacheBuster}`;
        if (window.DEBUG_MODE) {
            console.log('Loading camera stream using main configuration:', streamUrl);
        }
        
        // Add load handler
        feedImage.onload = function() {
            if (window.DEBUG_MODE) {
                console.log('Video stream loaded successfully');
            }
            originalFeed.innerHTML = '';
            originalFeed.appendChild(feedImage);
            
            // Create a copy for the analysis feed
            const analysisImage = feedImage.cloneNode(true);
            analysisImage.id = 'analysis-feed-image';
            
            // Clear analysis feed and add image
            analysisFeed.innerHTML = '';
            analysisFeed.appendChild(analysisImage);
            
            // Ensure overlay container exists
            let overlayContainer = document.getElementById('overlay-container');
            if (!overlayContainer) {
                overlayContainer = document.createElement('div');
                overlayContainer.id = 'overlay-container';
                overlayContainer.style.position = 'absolute';
                overlayContainer.style.top = '0';
                overlayContainer.style.left = '0';
                overlayContainer.style.width = '100%';
                overlayContainer.style.height = '100%';
                overlayContainer.style.pointerEvents = 'none';
                analysisFeed.appendChild(overlayContainer);
            }
            
            // Position the analysis feed container as relative to allow absolute positioning of overlays
            analysisFeed.style.position = 'relative';
        };
        
        // Add error handler
        feedImage.onerror = function() {
            console.error('Camera stream error occurred for URL:', streamUrl);
            const errorMessage = `
                <div style="width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;background:#333;text-align:center;padding:20px;">
                    <i class="fas fa-exclamation-triangle fa-3x mb-3" style="color:#ffc107;"></i>
                    <h5>Camera Stream Failed</h5>
                    <p>Could not load camera from configuration</p>
                    <p style="font-size:0.9em;">Please check:</p>
                    <ul style="text-align:left;font-size:0.8em;">
                        <li>Camera is properly configured in Settings</li>
                        <li>Camera/device is accessible</li>
                        <li>Network connection (for IP cameras)</li>
                        <li>Check system logs for detailed errors</li>
                    </ul>
                    <button class="btn btn-sm btn-warning mt-2" onclick="initializeVideoFeeds()">Retry</button>
                </div>
            `;
            originalFeed.innerHTML = errorMessage;
            analysisFeed.innerHTML = errorMessage;
        };
        
        // Set the source - this will trigger either onload or onerror
        feedImage.src = streamUrl;
    }

    function resetFeedPlaceholders() {
        const originalFeed = document.getElementById('original-feed');
        const analysisFeed = document.getElementById('analysis-feed');
        
        // Clear the feeds
        originalFeed.innerHTML = '<div class="empty-feed">Camera feed will appear here</div>';
        analysisFeed.innerHTML = '<div class="empty-feed">Analysis feed will appear here</div>';
    }

    function captureVideoFrames() {
        // Check if analysis is still active before proceeding
        if (!analysisActive) {
            if (window.DEBUG_MODE) {
                console.log('Analysis stopped, ending frame capture');
            }
            return;
        }
        
        // Use setInterval for more reliable timing control
        frameInterval = setInterval(() => {
            if (!analysisActive) {
                clearInterval(frameInterval);
                frameInterval = null;
                return;
            }
            
            const feedImage = document.getElementById('original-feed-image');
            if (!feedImage || !feedImage.complete) {
                // Image not loaded yet, skip this iteration
                return;
            }
            
            // Process current frame
            processVideoFrame(feedImage);
        }, analysisDelay);
    }

    async function processVideoFrame(feedImage) {
        // Double-check analysis is still active
        if (!analysisActive) {
                            if (window.DEBUG_MODE) {
                    console.log('Analysis stopped during frame processing');
                }
            return;
        }
        
        try {
            // Get current image dimensions
            const imageWidth = feedImage.clientWidth;
            const imageHeight = feedImage.clientHeight;
            
            if (!imageWidth || !imageHeight) {
                console.warn('Invalid image dimensions:', imageWidth, imageHeight);
                return;
            }
            
            // Create a temporary canvas to capture frame
            let canvas = document.getElementById('temp-canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.id = 'temp-canvas';
                canvas.style.display = 'none';
                document.body.appendChild(canvas);
            }
            
            // Set canvas size to match image
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            
            // Draw the current frame to canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(feedImage, 0, 0, imageWidth, imageHeight);
            
            // Get the image data as base64
            const imageData = canvas.toDataURL('image/jpeg', 0.7);
            
            // Send to server for analysis only if still active
            if (analysisActive) {
                await detectObjectsInFrame(imageData, imageWidth, imageHeight);
            }
        } catch (error) {
            console.error('Error processing video frame:', error);
        }
    }

    async function detectObjectsInFrame(imageData, width, height) {
        // Early return if analysis has been stopped
        if (!analysisActive) {
            if (window.DEBUG_MODE) {
                console.log('Analysis stopped, skipping frame detection');
            }
            return;
        }
        
        try {
            // Get overlay container
            const overlayContainer = document.getElementById('overlay-container');
            if (!overlayContainer) {
                console.error('Overlay container not found!');
                return;
            }
            
            // Get actual analysis image display dimensions for proper scaling
            const analysisImage = document.getElementById('analysis-feed-image');
            if (!analysisImage) {
                console.error('Analysis image not found!');
                return;
            }
            
            const displayWidth = analysisImage.clientWidth;
            const displayHeight = analysisImage.clientHeight;
            
            if (window.DEBUG_MODE) {
                console.log('Sending frame for analysis...', { 
                    captureSize: { width, height }, 
                    displaySize: { width: displayWidth, height: displayHeight }, 
                    selectedOverlay,
                    resolutionMismatch: width !== displayWidth || height !== displayHeight
                });
            }
            
            // Create AbortController for this request
            abortController = new AbortController();
            
            // Send the frame to the server for analysis
            const response = await fetch('/api/analyze_frame', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    image_data: imageData,
                    width: width,
                    height: height,
                    selected_overlay: selectedOverlay
                }),
                signal: abortController.signal
            });
            
            // Check again if analysis is still active after the async operation
            if (!analysisActive) {
                if (window.DEBUG_MODE) {
                    console.log('Analysis stopped during fetch, aborting processing');
                }
                return;
            }
            
            if (!response.ok) {
                console.error('Analysis API returned error:', response.status, response.statusText);
                return;
            }
            
            const result = await response.json();
            
            // Final check before processing results
            if (!analysisActive) {
                if (window.DEBUG_MODE) {
                    console.log('Analysis stopped after receiving results, aborting processing');
                }
                return;
            }
            
            if (window.DEBUG_MODE) {
                console.log('Raw analysis result:', result);
            }
            
            // Validate response structure first
            if (!result.detections || !result.detections.people) {
                if (window.DEBUG_MODE) console.error('Unexpected response structure:', result);
                return;
            }
            
            // Calculate scaling factors from backend frame resolution to display resolution
            // Use actual frame info from backend instead of hardcoded 1280x720
            const backendWidth = result.frame_info?.width || 1280;
            const backendHeight = result.frame_info?.height || 720;
            const scaleX = displayWidth / backendWidth;
            const scaleY = displayHeight / backendHeight;
            
            if (window.DEBUG_MODE) {
                console.log('Scaling calculation:', {
                    backendResolution: [backendWidth, backendHeight],
                    displayResolution: [displayWidth, displayHeight],
                    scaleFactors: [scaleX, scaleY]
                });
            }
            
            // Process people data with enhanced tracking
            const newDetectedObjects = result.detections.people.map((person, index) => {
                // Use the backend-provided ID (should be consistent now)
                const personId = person.id;
                
                if (!person.bbox || person.bbox.length < 4) {
                    console.warn('Person missing bbox property:', person);
                    return null;
                }
                
                // Scale bounding box from backend resolution (1280x720) to display resolution
                // Backend always sends [x, y, width, height] format
                const scaledX = person.bbox[0] * scaleX;
                const scaledY = person.bbox[1] * scaleY;
                const scaledWidth = person.bbox[2] * scaleX;
                const scaledHeight = person.bbox[3] * scaleY;
                
                if (window.DEBUG_MODE) {
                    console.log(`Person ${personId} coordinates:`, {
                        original: person.bbox,
                        scaled: [scaledX, scaledY, scaledWidth, scaledHeight],
                        scaleFactors: [scaleX, scaleY],
                        displaySize: [displayWidth, displayHeight],
                        backendResolution: [backendWidth, backendHeight]
                    });
                }
                
                // Find existing person data for continuity
                const existingPerson = detectedObjects.find(obj => obj.id === personId);
                
                // Extract demographics with proper handling
                const demographics = person.demographics || {};
                console.log(`Person ${personId} demographics:`, demographics); // Debug log
                
                return {
                    id: personId,
                    x: scaledX,
                    y: scaledY,
                    width: scaledWidth,
                    height: scaledHeight,
                    center: [(scaledX + scaledWidth/2), (scaledY + scaledHeight/2)],
                    confidence: person.confidence || 0.5,
                    frames_tracked: person.frames_tracked || 1,
                    demographics: {
                        gender: demographics.gender && demographics.gender !== 'unknown' && demographics.gender !== 'analyzing...' ? demographics.gender : 'analyzing...',
                        age_group: demographics.age_group && demographics.age_group !== 'unknown' && demographics.age_group !== 'analyzing...' ? demographics.age_group : 'analyzing...',
                        age: demographics.age || null,  // Include specific age from enhanced analysis
                        analysis_method: demographics.analysis_method || 'unknown',
                        emotion: demographics.emotion || 'neutral',
                        confidence: demographics.confidence || 0.1
                    },
                    dwell_time: person.dwell_time || person.zone_dwell_time || 0,
                    zone_dwell_time: person.zone_dwell_time || person.dwell_time || 0,
                    zone_id: person.zone_id || 0,
                    zone_name: person.zone_name || 'Outside',
                    path: person.path || [],
                    // Preserve movement history for smooth tracking
                    movement_history: existingPerson ? 
                        [...(existingPerson.movement_history || []), {
                            x: person.center?.[0] || (person.bbox[0] + person.bbox[2]/2),
                            y: person.center?.[1] || (person.bbox[1] + person.bbox[3]/2),
                            timestamp: Date.now()
                        }].slice(-20) : // Keep last 20 positions
                        [{
                            x: person.center?.[0] || (person.bbox[0] + person.bbox[2]/2),
                            y: person.center?.[1] || (person.bbox[1] + person.bbox[3]/2),
                            timestamp: Date.now()
                        }]
                };
            }).filter(person => person !== null);
            
            // Update detectedObjects with new data
            detectedObjects = newDetectedObjects;
            
            if (window.DEBUG_MODE) {
                console.log('Processed detected objects with tracking:', detectedObjects);
            }
            
            // Enhanced heatmap processing using both current detections and persistent paths
            if (result.heatmap && result.heatmap.points) {
                const newHeatmapPoints = result.heatmap.points.map(p => ({
                    x: p.x * scaleX,
                    y: p.y * scaleY,
                    intensity: p.value,
                    id: p.id || 'unknown',
                    timestamp: Date.now()
                }));
                
                // Merge with existing movement history, removing old points
                movementHistory = [...movementHistory, ...newHeatmapPoints];
                
                // Remove points older than 30 seconds
                const cutoffTime = Date.now() - 30000;
                movementHistory = movementHistory.filter(point => point.timestamp > cutoffTime);
                
                // Limit total history size
                if (movementHistory.length > 1000) {
                    movementHistory = movementHistory.slice(-1000);
                }
            }
            
            // Process path data from the backend
            if (result.paths) {
                for (const [personId, pathPoints] of Object.entries(result.paths)) {
                    const person = detectedObjects.find(obj => obj.id == personId);
                    if (person && pathPoints.length > 0) {
                        person.path = pathPoints.map(point => ({
                            x: point.x * scaleX,
                            y: point.y * scaleY,
                            timestamp: point.timestamp || Date.now(),
                            confidence: point.confidence || 0.5
                        }));
                    }
                }
            }
            
            // Update detected objects display with anti-flashing system
            updateDetectedObjects(overlayContainer);
            
            // Update analytics with enhanced demographics
            updateEnhancedAnalytics(result);
            
            // Update the selected overlay
            updateAnalysisView();
        }
        catch (error) {
            if (error.name === 'AbortError') {
                if (window.DEBUG_MODE) {
                    console.log('Frame analysis request was cancelled');
                }
                return;
            }
            console.error('Error analyzing frame:', error);
            console.error('Error stack:', error.stack);
        }
    }
    
    function updateEnhancedAnalytics(result) {
        // Update people count
        const peopleCountElement = document.getElementById('people-count');
        if (peopleCountElement) {
            peopleCountElement.textContent = detectedObjects.length;
        }
        
        // Enhanced gender ratio with proper analysis
        const genderRatioElement = document.getElementById('gender-ratio');
        if (genderRatioElement) {
            let maleCount = 0;
            let femaleCount = 0;
            
            detectedObjects.forEach(obj => {
                const gender = obj.demographics?.gender;
                if (gender === 'male') maleCount++;
                else if (gender === 'female') femaleCount++;
            });
            
            // Also check analytics from backend
            if (result.analytics) {
                maleCount = Math.max(maleCount, result.analytics.male_count || 0);
                femaleCount = Math.max(femaleCount, result.analytics.female_count || 0);
            }
            
            genderRatioElement.textContent = `${maleCount}/${femaleCount}`;
        }
        
        // Enhanced average age with backend data
        const avgAgeElement = document.getElementById('avg-age');
        if (avgAgeElement) {
            let ageDisplay = '--';
            
            // Collect specific ages from enhanced analysis
            const specificAges = detectedObjects
                .filter(obj => obj.demographics?.age && obj.demographics?.analysis_method && 
                              (obj.demographics.analysis_method === 'deepface_insightface' || 
                               obj.demographics.analysis_method === 'enhanced') &&
                              obj.demographics.confidence > 0.3)
                .map(obj => obj.demographics.age);
            
            // Calculate average of specific ages if available
            if (specificAges.length > 0) {
                const avgAge = Math.round(specificAges.reduce((sum, age) => sum + age, 0) / specificAges.length);
                ageDisplay = `Avg ${avgAge}`;
            } else {
                // Fall back to age groups from detected objects
                const ageGroups = detectedObjects
                    .map(obj => obj.demographics?.age_group)
                    .filter(age => age && age !== 'unknown' && age !== 'analyzing...');
                
                // Also check backend analytics
                if (result.analytics?.age_groups && Object.keys(result.analytics.age_groups).length > 0) {
                    const mostCommonAge = Object.entries(result.analytics.age_groups)
                        .sort(([,a], [,b]) => b - a)[0]?.[0];
                    if (mostCommonAge) ageDisplay = mostCommonAge;
                } else if (ageGroups.length > 0) {
                    ageDisplay = ageGroups[0]; // Show first available age group
                }
            }
            
            avgAgeElement.textContent = ageDisplay;
        }
        
        // Enhanced traffic level
        const currentTrafficElement = document.getElementById('current-traffic');
        if (currentTrafficElement) {
            let trafficLevel = 'Low';
            const peopleCount = detectedObjects.length;
            
            if (peopleCount > 5) trafficLevel = 'High';
            else if (peopleCount > 2) trafficLevel = 'Medium';
            
            currentTrafficElement.textContent = trafficLevel;
        }
        
        // Enhanced dwell time with backend data
        const dwellTimeElement = document.getElementById('current-dwell-time');
        if (dwellTimeElement) {
            let avgDwell = 0;
            
            // Use backend analytics if available
            if (result.analytics?.average_dwell_time) {
                avgDwell = result.analytics.average_dwell_time;
            } else if (detectedObjects.length > 0) {
                // Calculate from detected objects, using zone_dwell_time if available
                const dwellTimes = detectedObjects.map(obj => {
                    return Math.max(obj.dwell_time || 0, obj.zone_dwell_time || 0);
                });
                avgDwell = dwellTimes.reduce((sum, dwell) => sum + dwell, 0) / dwellTimes.length;
            }
            
            dwellTimeElement.textContent = avgDwell > 0 ? `${Math.round(avgDwell)} sec` : '-- sec';
            
            // Debug log for dwell time tracking
            if (window.DEBUG_MODE && detectedObjects.length > 0) {
                console.log('Dwell time update:', {
                    backendAvg: result.analytics?.average_dwell_time,
                    calculatedAvg: avgDwell,
                    objectDwellTimes: detectedObjects.map(obj => ({
                        id: obj.id,
                        dwell_time: obj.dwell_time,
                        zone_dwell_time: obj.zone_dwell_time,
                        zone_name: obj.zone_name
                    }))
                });
            }
        }
        
        // Log analytics if debug mode enabled
        if (result.analytics && window.DEBUG_MODE) {
            console.log('Backend analytics:', result.analytics);
        }
    }
    
    function updateAnalysisView() {
        const overlayContainer = document.getElementById('overlay-container');
        if (!overlayContainer) return;
        
        // Remove any existing overlay elements except bounding boxes
        Array.from(overlayContainer.children).forEach(child => {
            if (!child.classList.contains('person-element') && 
                !child.classList.contains('heatmap-canvas')) {
                child.remove();
            }
        });
        
        // Apply the selected overlay
        if (selectedOverlay === 'heatmap') {
            applyHeatmapOverlay(overlayContainer);
        } else if (selectedOverlay === 'facial') {
            createFacialOverlay(overlayContainer);

        } else if (selectedOverlay === 'demographic') {
            createDemographicOverlay(overlayContainer);
        } else if (selectedOverlay === 'dwell') {
            createDwellTimeOverlay(overlayContainer);
        }
    }
    
    function applyHeatmapOverlay(container) {
        // Find or create heatmap canvas
        let heatmapCanvas = container.querySelector('.heatmap-canvas');
        if (!heatmapCanvas) {
            heatmapCanvas = document.createElement('canvas');
            heatmapCanvas.className = 'heatmap-canvas';
            heatmapCanvas.width = container.offsetWidth;
            heatmapCanvas.height = container.offsetHeight;
            container.appendChild(heatmapCanvas);
        }
        
        // Get the context and clear it
        const ctx = heatmapCanvas.getContext('2d');
        
        // Apply opacity from slider
        const opacity = parseInt(document.getElementById('heatmap-opacity').value) / 100;
        ctx.globalAlpha = opacity;
        
        // Check which heatmap type is selected
        const isTrafficHeatmap = document.getElementById('traffic-heatmap').checked;
        
        if (isTrafficHeatmap) {
            drawTrafficHeatmap(ctx, container.offsetWidth, container.offsetHeight);
        } else {
            drawDwellTimeHeatmap(ctx, container.offsetWidth, container.offsetHeight);
        }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;
    }
    
    // Helper functions
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
    }
    
    // Overlay rendering functions 
    function drawTrafficHeatmap(ctx, width, height) {
        // Clear the context first
        ctx.clearRect(0, 0, width, height);
        
        // Draw heat for each detected person using their full bounding box
        detectedObjects.forEach(obj => {
            const boxCenterX = obj.x + obj.width / 2;
            const boxCenterY = obj.y + obj.height / 2;
            
            // Use bounding box dimensions to determine heat area
            const heatWidth = Math.max(50, obj.width * 1.2);  // Slightly larger than bbox
            const heatHeight = Math.max(50, obj.height * 1.2);
            const maxRadius = Math.max(heatWidth, heatHeight) / 2;
            
            // Create gradient based on bounding box size
            const gradient = ctx.createRadialGradient(
                boxCenterX, boxCenterY, 0,
                boxCenterX, boxCenterY, maxRadius
            );
            
            // Much lower intensity for subtle heat visualization
            const baseIntensity = 0.15 + (obj.confidence * 0.1); // Max 0.25
            gradient.addColorStop(0, `rgba(255, 80, 0, ${baseIntensity})`); // Orange center
            gradient.addColorStop(0.4, `rgba(255, 150, 0, ${baseIntensity * 0.7})`); // Yellow-orange mid
            gradient.addColorStop(0.8, `rgba(255, 200, 100, ${baseIntensity * 0.3})`); // Light yellow
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent edge
            
            // Draw elliptical heat area matching person's bounding box proportions
            ctx.save();
            ctx.translate(boxCenterX, boxCenterY);
            ctx.scale(heatWidth / (maxRadius * 2), heatHeight / (maxRadius * 2));
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
        
        // Also include movement history points but with even lower intensity
        movementHistory.forEach(point => {
            const radius = 25 + (point.intensity || 0.5) * 15; // Smaller radius
            const gradient = ctx.createRadialGradient(
                point.x, point.y, 0,
                point.x, point.y, radius
            );
            
            // Very subtle historical heat
            const histIntensity = Math.min(0.08, (point.intensity || 0.5) * 0.1);
            gradient.addColorStop(0, `rgba(255, 100, 50, ${histIntensity})`); // Light orange center
            gradient.addColorStop(0.6, `rgba(255, 180, 100, ${histIntensity * 0.5})`); // Very light orange mid
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent edge
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Apply subtle blur for smoother heatmap
        ctx.filter = 'blur(8px)';
        ctx.drawImage(ctx.canvas, 0, 0);
        ctx.filter = 'none';
    }
    
    function drawDwellTimeHeatmap(ctx, width, height) {
        // Create dwell time zones based on detected objects
        ctx.clearRect(0, 0, width, height);
        
        // Create heatmap for each person based on dwell time using their bounding box
        detectedObjects.forEach(obj => {
            // Calculate center of object
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            
            // Use bounding box dimensions for heat area
            const dwellTime = obj.dwell_time || 1;
            const heatWidth = Math.max(40, obj.width * 1.3);  // Larger for dwell areas
            const heatHeight = Math.max(40, obj.height * 1.3);
            const maxRadius = Math.max(heatWidth, heatHeight) / 2;
            
            // Color intensity based on dwell time (0-60 seconds mapped to 0-0.2 max)
            const normalizedDwell = Math.min(dwellTime / 60, 1.0); // Normalize to 0-1
            const baseIntensity = 0.05 + (normalizedDwell * 0.15); // Max 0.2 intensity
            
            // Create gradient based on bounding box
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, maxRadius
            );
            
            // Blue-cyan gradient for dwell time visualization
            gradient.addColorStop(0, `rgba(0, 150, 255, ${baseIntensity})`); // Blue center
            gradient.addColorStop(0.4, `rgba(50, 200, 255, ${baseIntensity * 0.7})`); // Light blue mid
            gradient.addColorStop(0.8, `rgba(100, 220, 255, ${baseIntensity * 0.3})`); // Very light blue
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent edge
            
            // Draw elliptical dwell area matching person's bounding box proportions
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.scale(heatWidth / (maxRadius * 2), heatHeight / (maxRadius * 2));
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, maxRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
        
        // Apply subtle blur for smoother appearance
        ctx.filter = 'blur(6px)';
        ctx.drawImage(ctx.canvas, 0, 0);
        ctx.filter = 'none';
    }
    
    function createFacialOverlay(container) {
        if (window.DEBUG_MODE) {
            console.log('Creating facial overlay with detected objects:', detectedObjects);
        }
        
        // Check which facial options are enabled
        const showAge = document.getElementById('show-age')?.checked || false;
        const showGender = document.getElementById('show-gender')?.checked || false;
        const showEmotion = document.getElementById('show-emotion')?.checked || false;
        
        // Update person boxes to show facial recognition info
        detectedObjects.forEach(person => {
            const personElement = container.querySelector(`.person-element[data-id="${person.id}"]`);
            if (!personElement) return;
            
            // Remove any existing facial labels
            const existingFacialLabel = personElement.querySelector('.facial-label');
            if (existingFacialLabel) {
                existingFacialLabel.remove();
            }
            
            // Create facial recognition label
            const facialLabel = document.createElement('div');
            facialLabel.className = 'person-label facial-label';
            facialLabel.style.position = 'absolute';
            facialLabel.style.top = '-50px';
            facialLabel.style.left = '0';
            facialLabel.style.backgroundColor = 'rgba(255, 153, 0, 0.9)';
            facialLabel.style.color = 'white';
            facialLabel.style.padding = '3px 6px';
            facialLabel.style.borderRadius = '3px';
            facialLabel.style.fontSize = '11px';
            facialLabel.style.fontWeight = 'bold';
            facialLabel.style.whiteSpace = 'nowrap';
            facialLabel.style.zIndex = '30';
            facialLabel.style.pointerEvents = 'none';
            
            // Get demographic info from actual person data
            const demographics = person.demographics || {};
            const gender = demographics.gender || 'unknown';
            const ageGroup = demographics.age_group || 'unknown';
            const specificAge = demographics.age;
            const analysisMethod = demographics.analysis_method || 'unknown';
            const emotion = demographics.emotion || 'neutral';
            const confidence = demographics.confidence || 0;
            
            // Build label text based on user preferences
            let labelText = '';
            if (showGender && gender !== 'unknown') {
                labelText += gender.charAt(0).toUpperCase() + gender.slice(1) + ' ';
            }
            if (showAge && ageGroup !== 'unknown') {
                // Use specific age for enhanced analysis, age group for fallback methods
                if (specificAge && (analysisMethod === 'deepface_insightface' || analysisMethod === 'enhanced') && confidence > 0.3) {
                    labelText += `${specificAge} `;
                } else if (ageGroup !== 'analyzing...') {
                    labelText += ageGroup + ' ';
                }
            }
            if (showEmotion && emotion !== 'neutral') {
                const emotionEmoji = emotion === 'happy' ? '' : emotion === 'calm' ? '' : emotion === 'focused' ? '' : '';
                labelText += emotionEmoji + emotion.charAt(0).toUpperCase() + emotion.slice(1) + ' ';
            }
            
            // Add confidence indicator for face detection quality
            if (confidence > 0.1) {
                labelText += `(${Math.round(confidence * 100)}%)`;
            }
            
            // Set label text or show analysis status
            if (labelText.trim()) {
                facialLabel.textContent = labelText.trim();
            } else if (gender === 'unknown' && ageGroup === 'unknown') {
                facialLabel.textContent = 'Analyzing face...';
                facialLabel.style.backgroundColor = 'rgba(128, 128, 128, 0.8)';
            } else {
                facialLabel.textContent = 'Face detected';
            }
            
            personElement.appendChild(facialLabel);
            
            // Change box color for facial recognition with confidence-based intensity
            const alpha = Math.max(0.3, confidence);
            personElement.style.border = `2px solid rgba(255, 153, 0, ${alpha})`;
            personElement.style.boxShadow = `0 0 8px rgba(255, 153, 0, ${alpha * 0.5})`;
        });
        
        // Add a facial analysis summary panel
        createFacialAnalysisSummary(container);
    }
    
    function createFacialAnalysisSummary(container) {
        const summaryPanel = document.createElement('div');
        summaryPanel.className = 'facial-analysis-summary';
        summaryPanel.style.position = 'absolute';
        summaryPanel.style.top = '10px';
        summaryPanel.style.left = '10px';
        summaryPanel.style.backgroundColor = 'rgba(255, 153, 0, 0.9)';
        summaryPanel.style.color = 'white';
        summaryPanel.style.padding = '10px';
        summaryPanel.style.borderRadius = '6px';
        summaryPanel.style.fontSize = '12px';
        summaryPanel.style.maxWidth = '200px';
        summaryPanel.style.zIndex = '25';
        summaryPanel.style.fontFamily = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        
        // Count faces detected and analysed
        let facesDetected = 0;
        let facesAnalysed = 0;
        let totalConfidence = 0;
        
        detectedObjects.forEach(person => {
            const demographics = person.demographics || {};
            if (demographics.confidence > 0.1) {
                facesDetected++;
                if (demographics.gender !== 'unknown' || demographics.age_group !== 'unknown') {
                    facesAnalysed++;
                    totalConfidence += demographics.confidence;
                }
            }
        });
        
        const avgConfidence = facesAnalysed > 0 ? (totalConfidence / facesAnalysed) : 0;
        
        summaryPanel.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;"> Facial Analysis</div>
            <div>People detected: ${detectedObjects.length}</div>
            <div>Faces detected: ${facesDetected}</div>
            <div>Faces analysed: ${facesAnalysed}</div>
            ${avgConfidence > 0 ? `<div>Avg. confidence: ${Math.round(avgConfidence * 100)}%</div>` : ''}
            <div style="margin-top: 5px; font-size: 10px; color: #ffeeaa;">
                Analysis based on OpenCV face detection
            </div>
        `;
        
        container.appendChild(summaryPanel);
    }
    

    
    function createDemographicOverlay(container) {
        // Create a demographic overlay panel
        const demographicOverlay = document.createElement('div');
        demographicOverlay.className = 'demographic-overlay';
        demographicOverlay.style.position = 'absolute';
        demographicOverlay.style.top = '10px';
        demographicOverlay.style.right = '10px';
        demographicOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        demographicOverlay.style.color = '#fff';
        demographicOverlay.style.padding = '12px';
        demographicOverlay.style.borderRadius = '6px';
        demographicOverlay.style.maxWidth = '250px';
        demographicOverlay.style.fontSize = '12px';
        demographicOverlay.style.zIndex = '25';
        demographicOverlay.style.fontFamily = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
        
        if (window.DEBUG_MODE) {
            console.log('Creating demographics overlay with data:', detectedObjects);
        }
        
        // Use actual detected objects data instead of DOM elements
        let maleCount = 0;
        let femaleCount = 0;
        let unknownGender = 0;
        const ageGroups = {};
        const emotions = {};
        const confidenceSum = { total: 0, count: 0 };
        
        // Process each detected person
        detectedObjects.forEach(person => {
            const demographics = person.demographics || {};
            
            // Count gender with better validation
            const gender = demographics.gender?.toLowerCase();
            const genderConfidence = demographics.confidence || 0;
            console.log(`Counting person ${person.id}: gender="${gender}", confidence=${genderConfidence.toFixed(2)}, age_group="${demographics.age_group}", specific_age=${demographics.age}, method="${demographics.analysis_method}"`);
            
            if (gender === 'male' || gender === 'man') {
                maleCount++;
            } else if (gender === 'female' || gender === 'woman') {
                femaleCount++;
            } else if (gender !== 'analyzing...' && gender !== 'unknown' && genderConfidence > 0.2) {
                // If it's not analyzing or unknown and has reasonable confidence, try to parse gender
                if (gender && (gender.includes('male') || gender.includes('man'))) {
                    maleCount++;
                } else if (gender && (gender.includes('female') || gender.includes('woman'))) {
                    femaleCount++;
                } else {
                    unknownGender++;
                }
            } else if (gender === 'analyzing...') {
                // Count analyzing as separate category for progress display
                unknownGender++;
            } else {
                unknownGender++;
            }
            
            // Count age groups with better validation - use specific age for enhanced analysis
            const ageGroup = demographics.age_group;
            const specificAge = demographics.age;
            const analysisMethod = demographics.analysis_method || 'unknown';
            
            if (specificAge && (analysisMethod === 'deepface_insightface' || analysisMethod === 'enhanced') && genderConfidence > 0.3) {
                // Use specific age for enhanced analysis
                const ageKey = `Age ${specificAge}`;
                ageGroups[ageKey] = (ageGroups[ageKey] || 0) + 1;
            } else if (ageGroup && ageGroup !== 'unknown' && ageGroup !== 'analyzing...' && ageGroup.trim().length > 0) {
                // Fall back to age groups for basic analysis
                ageGroups[ageGroup] = (ageGroups[ageGroup] || 0) + 1;
            }
            
            // Count emotions
            const emotion = demographics.emotion;
            if (emotion && emotion !== 'unknown') {
                emotions[emotion] = (emotions[emotion] || 0) + 1;
            }
            
            // Track demographic confidence
            const demoConfidence = demographics.confidence || 0;
            if (demoConfidence > 0.3) { // Only count reasonably confident detections
                confidenceSum.total += demoConfidence;
                confidenceSum.count++;
            }
            
            // Change box color for demographic view
            const personElement = container.querySelector(`.person-element[data-id="${person.id}"]`);
            if (personElement) {
                personElement.style.border = '2px solid #9900ff';
                personElement.style.boxShadow = '0 0 8px rgba(153, 0, 255, 0.4)';
            }
        });
        
        const totalPeople = detectedObjects.length;
        const avgConfidence = confidenceSum.count > 0 ? (confidenceSum.total / confidenceSum.count) : 0;
        
        // Create detailed demographic summary
        let demographicsHTML = `
            <h5 style="margin:0 0 10px 0;font-size:14px;color:#9900ff;"> Demographics Analysis</h5>
            <div style="margin-bottom:8px;"><strong>Total People:</strong> ${totalPeople}</div>
        `;
        
        // Gender distribution
        if (maleCount > 0 || femaleCount > 0) {
            demographicsHTML += `
                <div style="margin:8px 0 5px 0;"><strong>Gender Distribution:</strong></div>
                <div style="padding-left:8px;">
                    <div> Male: ${maleCount} (${totalPeople ? Math.round(maleCount/totalPeople*100) : 0}%)</div>
                    <div> Female: ${femaleCount} (${totalPeople ? Math.round(femaleCount/totalPeople*100) : 0}%)</div>
                    ${unknownGender > 0 ? `<div> Unknown: ${unknownGender} (${Math.round(unknownGender/totalPeople*100)}%)</div>` : ''}
                </div>
            `;
        } else if (totalPeople > 0) {
            demographicsHTML += `<div style="color:#orange;font-style:italic;"> Gender analysis in progress... (${totalPeople} people detected)</div>`;
        } else {
            demographicsHTML += `<div style="color:#ccc;font-style:italic;"> No people detected yet</div>`;
        }
        
        // Age distribution
        if (Object.keys(ageGroups).length > 0) {
            demographicsHTML += `<div style="margin:8px 0 5px 0;"><strong>Age Groups:</strong></div><div style="padding-left:8px;">`;
            Object.entries(ageGroups).forEach(([age, count]) => {
                const percentage = totalPeople ? Math.round((count / totalPeople) * 100) : 0;
                demographicsHTML += `<div> ${age}: ${count} (${percentage}%)</div>`;
            });
            demographicsHTML += '</div>';
        } else if (totalPeople > 0) {
            demographicsHTML += `<div style="color:#orange;font-style:italic;"> Age analysis in progress... (${totalPeople} people detected)</div>`;
        } else {
            demographicsHTML += `<div style="color:#ccc;font-style:italic;"> No age data available yet</div>`;
        }
        
        // Emotions
        if (Object.keys(emotions).length > 0) {
            demographicsHTML += `<div style="margin:8px 0 5px 0;"><strong>Emotions:</strong></div><div style="padding-left:8px;">`;
            Object.entries(emotions).forEach(([emotion, count]) => {
                const percentage = totalPeople ? Math.round((count / totalPeople) * 100) : 0;
                const emoji = emotion === 'happy' ? '' : emotion === 'sad' ? '' : emotion === 'angry' ? '' : '';
                demographicsHTML += `<div>${emoji} ${emotion}: ${count} (${percentage}%)</div>`;
            });
            demographicsHTML += '</div>';
        }
        
        // Analysis confidence
        if (avgConfidence > 0) {
            demographicsHTML += `
                <div style="margin-top:8px;padding-top:8px;border-top:1px solid #555;font-size:10px;color:#ccc;">
                    Analysis Confidence: ${Math.round(avgConfidence * 100)}%
                </div>
            `;
        }
        
        demographicOverlay.innerHTML = demographicsHTML;
        
        // Add to container
        container.appendChild(demographicOverlay);
    }
    
    function createDwellTimeOverlay(container) {
        // Update each person with dwell time visualization and zone information
        const people = container.querySelectorAll('.person-element');
        
        people.forEach(person => {
            // Change box color for dwell time view
            person.style.border = '2px solid #ff00ff';
            
            // Get person data
            const dwellTime = parseInt(person.dataset.dwellTime || '0');
            const personId = person.dataset.id;
            
            // Get zone information for this person
            const personX = parseFloat(person.style.left) + parseFloat(person.style.width) / 2;
            const personY = parseFloat(person.style.top) + parseFloat(person.style.height) / 2;
            const zoneName = getZoneNameByPoint(personX, personY);
            
            // Create a comprehensive dwell time label with zone info
            const dwellLabel = document.createElement('div');
            dwellLabel.className = 'person-label dwell-label';
            dwellLabel.style.position = 'absolute';
            dwellLabel.style.top = '-35px';
            dwellLabel.style.left = '0';
            dwellLabel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            dwellLabel.style.color = '#fff';
            dwellLabel.style.padding = '4px 8px';
            dwellLabel.style.borderRadius = '4px';
            dwellLabel.style.fontSize = '11px';
            dwellLabel.style.lineHeight = '1.2';
            dwellLabel.style.minWidth = '120px';
            
            // Multi-line label with zone and dwell time
            dwellLabel.innerHTML = `
                <div style="font-weight: bold;">${formatTime(dwellTime)}</div>
                <div style="font-size: 10px; opacity: 0.9;">Zone: ${zoneName}</div>
            `;
            
            person.appendChild(dwellLabel);
            
            // Create a circular timer indicator
            const timerCircle = document.createElement('div');
            timerCircle.className = 'timer-circle';
            timerCircle.style.position = 'absolute';
            timerCircle.style.top = '-5px';
            timerCircle.style.right = '-5px';
            timerCircle.style.width = '15px';
            timerCircle.style.height = '15px';
            timerCircle.style.borderRadius = '50%';
            timerCircle.style.border = '2px solid #ff00ff';
            
            // Color based on dwell time
            let circleColor = '#00ff00'; // Green for short dwell time
            if (dwellTime > 180) {
                circleColor = '#ff0000'; // Red for long dwell time
            } else if (dwellTime > 60) {
                circleColor = '#ffff00'; // Yellow for medium dwell time
            }
            
            timerCircle.style.backgroundColor = circleColor;
            person.appendChild(timerCircle);
        });
        
        // Create enhanced dwell time summary with zone statistics
        const dwellSummary = document.createElement('div');
        dwellSummary.className = 'dwell-summary';
        dwellSummary.style.position = 'absolute';
        dwellSummary.style.bottom = '10px';
        dwellSummary.style.right = '10px';
        dwellSummary.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        dwellSummary.style.color = '#fff';
        dwellSummary.style.padding = '10px';
        dwellSummary.style.borderRadius = '6px';
        dwellSummary.style.fontSize = '12px';
        dwellSummary.style.minWidth = '200px';
        dwellSummary.style.maxHeight = '200px';
        dwellSummary.style.overflowY = 'auto';
        
        // Calculate zone-based statistics
        const zoneStats = {};
        people.forEach(person => {
            const dwellTime = parseInt(person.dataset.dwellTime || '0');
            const personX = parseFloat(person.style.left) + parseFloat(person.style.width) / 2;
            const personY = parseFloat(person.style.top) + parseFloat(person.style.height) / 2;
            const zoneName = getZoneNameByPoint(personX, personY);
            
            if (!zoneStats[zoneName]) {
                zoneStats[zoneName] = {
                    count: 0,
                    totalDwell: 0,
                    people: []
                };
            }
            
            zoneStats[zoneName].count++;
            zoneStats[zoneName].totalDwell += dwellTime;
            zoneStats[zoneName].people.push(person.dataset.id || 'unknown');
        });
        
        // Calculate overall average
        const avgDwell = people.length 
            ? Array.from(people).reduce((sum, p) => sum + parseInt(p.dataset.dwellTime || '0'), 0) / people.length 
            : 0;
        
        // Build summary HTML
        let summaryHTML = `<div style="font-weight: bold; margin-bottom: 8px;">Dwell Time Analysis</div>`;
        summaryHTML += `<div style="margin-bottom: 8px;">Overall Avg: ${formatTime(Math.round(avgDwell))}</div>`;
        
        // Add zone breakdown
        if (Object.keys(zoneStats).length > 0) {
            summaryHTML += `<div style="font-weight: bold; margin-bottom: 4px; font-size: 11px;">By Zone:</div>`;
            
            Object.entries(zoneStats).forEach(([zoneName, stats]) => {
                const avgZoneDwell = stats.count > 0 ? stats.totalDwell / stats.count : 0;
                summaryHTML += `
                    <div style="margin-bottom: 3px; font-size: 10px;">
                        <span style="font-weight: bold;">${zoneName}:</span> 
                        ${stats.count} people, avg ${formatTime(Math.round(avgZoneDwell))}
                    </div>
                `;
            });
        }
        
        dwellSummary.innerHTML = summaryHTML;
        container.appendChild(dwellSummary);
        
        // Update zone overlays to show dwell time information
        updateZoneOverlaysWithDwellTime(container, zoneStats);
    }
    
    function updateZoneOverlaysWithDwellTime(container, zoneStats) {
        // Find existing zone overlays and update them with dwell time info
        const zoneOverlays = container.querySelectorAll('.zone-overlay');
        
        zoneOverlays.forEach((overlay, index) => {
            if (!window._zones || !window._zones[index]) return;
            
            const zone = window._zones[index];
            const zoneName = zone.name;
            const stats = zoneStats[zoneName] || { count: 0, totalDwell: 0 };
            
            // Add zone statistics label
            let existingLabel = overlay.querySelector('.zone-dwell-label');
            if (!existingLabel) {
                existingLabel = document.createElement('div');
                existingLabel.className = 'zone-dwell-label';
                existingLabel.style.position = 'absolute';
                existingLabel.style.top = '5px';
                existingLabel.style.left = '5px';
                existingLabel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                existingLabel.style.color = '#fff';
                existingLabel.style.padding = '4px 6px';
                existingLabel.style.borderRadius = '3px';
                existingLabel.style.fontSize = '10px';
                existingLabel.style.fontWeight = 'bold';
                existingLabel.style.pointerEvents = 'none';
                overlay.appendChild(existingLabel);
            }
            
            const avgDwell = stats.count > 0 ? Math.round(stats.totalDwell / stats.count) : 0;
            existingLabel.innerHTML = `
                <div>${zoneName}</div>
                <div style="font-size: 9px; opacity: 0.9;">
                    ${stats.count} people<br/>
                    Avg: ${formatTime(avgDwell)}
                </div>
            `;
            
            // Update zone overlay opacity based on activity
            const activity = Math.min(1, stats.count / 3); // Normalize to max 3 people
            overlay.style.backgroundColor = `rgba(255, 255, 255, ${0.05 + activity * 0.15})`;
        });
    }
    
    function updateDetectedObjects(container) {
        // Check if we should show bounding boxes and labels
        const showBoxes = document.getElementById('show-bounding-boxes')?.checked || false;
        const showLabels = document.getElementById('show-labels')?.checked || false;
        
        console.log('Update detected objects:', {
            detectedObjects: detectedObjects.length,
            showBoxes,
            showLabels
        });
        
        // Always show person elements for overlays to work, just control borders/labels
        
        // Get existing person elements
        const existingPeople = container.querySelectorAll('.person-element');
        
        // Create a map of existing elements by ID for fast lookup
        const existingMap = new Map();
        existingPeople.forEach(element => {
            const id = element.dataset.id;
            if (id) {
                existingMap.set(id, element);
            }
        });
        
        // Track which objects we've updated
        const updatedIds = new Set();
        
        // Update or create elements for each detected object
        detectedObjects.forEach(obj => {
            if (!obj.id) {
                console.warn('Object missing ID:', obj);
                return;
            }
            
            updatedIds.add(obj.id.toString());
            
            let personElement = existingMap.get(obj.id.toString());
            
            if (personElement) {
                // Update existing element smoothly
                updatePersonElement(personElement, obj, showBoxes, showLabels);
            } else {
                // Create new element for new detection
                personElement = createPersonElement(obj, showBoxes, showLabels);
                container.appendChild(personElement);
                if (window.DEBUG_MODE) {
                console.log('Created new person element for ID:', obj.id);
            }
            }
        });
        
        // Remove elements for objects that are no longer detected
        existingPeople.forEach(element => {
            const id = element.dataset.id;
            if (id && !updatedIds.has(id)) {
                // Fade out and remove element smoothly
                element.style.transition = 'opacity 0.3s ease-out';
                element.style.opacity = '0';
                setTimeout(() => {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                }, 300);
            }
        });
    }
    
    function updatePersonElement(element, obj, showBoxes, showLabels) {
        // Smooth position and size updates
        element.style.transition = 'left 0.1s ease, top 0.1s ease, width 0.1s ease, height 0.1s ease';
        element.style.left = `${obj.x}px`;
        element.style.top = `${obj.y}px`;
        element.style.width = `${obj.width}px`;
        element.style.height = `${obj.height}px`;
        element.style.opacity = '1';
        element.style.display = 'block';
        element.style.position = 'absolute';
        element.style.boxSizing = 'border-box';
        element.style.pointerEvents = 'none';
        element.style.zIndex = '20';
        
        // Update data attributes
        element.dataset.id = obj.id.toString();
        element.dataset.confidence = obj.confidence || 0.5;
        element.dataset.gender = obj.demographics?.gender || 'unknown';
        element.dataset.ageGroup = obj.demographics?.age_group || 'unknown';
        element.dataset.dwellTime = Math.round(Math.max(obj.dwell_time || 0, obj.zone_dwell_time || 0));
        element.dataset.zoneDwellTime = Math.round(obj.zone_dwell_time || obj.dwell_time || 0);
        element.dataset.zoneId = obj.zone_id || 0;
        element.dataset.zoneName = obj.zone_name || 'Outside';
        
        // Update border visibility
        if (showBoxes) {
            element.style.border = '2px solid #00ff00';
            element.style.background = 'rgba(0, 255, 0, 0.1)';
        } else {
            element.style.border = 'none';
            element.style.background = 'none';
        }
        
        // Update or remove enhanced label
        const existingLabelContainer = element.querySelector('.person-label-container');
        if (showLabels) {
            if (existingLabelContainer) {
                // Update existing enhanced label
                const demographics = obj.demographics || {};
                const gender = demographics.gender && demographics.gender !== 'unknown' && demographics.gender !== 'analyzing...' ? demographics.gender : 'Unknown';
                const ageGroup = demographics.age_group && demographics.age_group !== 'unknown' && demographics.age_group !== 'analyzing...' ? demographics.age_group : 'Unknown';
                const emotion = demographics.emotion || 'neutral';
                const confidence = Math.round((demographics.confidence || 0.1) * 100);
                const analysisMethod = demographics.analysis_method || 'standard';
                
                const primaryInfo = existingLabelContainer.querySelector('.person-info > div:first-child');
                const secondaryInfo = existingLabelContainer.querySelector('.person-info > div:last-child');
                
                if (primaryInfo) primaryInfo.textContent = `ID: ${obj.id} | ${gender}, ${ageGroup}`;
                if (secondaryInfo) secondaryInfo.textContent = `${emotion} (${confidence}%) | ${analysisMethod}`;
                
                // Update face thumbnail if needed
                const faceThumbnail = existingLabelContainer.querySelector('.face-thumbnail');
                if (faceThumbnail && !faceThumbnailCache.has(obj.id)) {
                    loadFaceThumbnail(obj.id, faceThumbnail);
                }
            } else {
                // Create new enhanced label (same as in createPersonElement)
                const labelContainer = document.createElement('div');
                labelContainer.className = 'person-label-container';
                labelContainer.style.position = 'absolute';
                labelContainer.style.top = '-45px';
                labelContainer.style.left = '0';
                labelContainer.style.display = 'flex';
                labelContainer.style.alignItems = 'center';
                labelContainer.style.background = 'rgba(0, 0, 0, 0.85)';
                labelContainer.style.color = 'white';
                labelContainer.style.padding = '3px 6px';
                labelContainer.style.borderRadius = '5px';
                labelContainer.style.fontSize = '11px';
                labelContainer.style.fontWeight = 'bold';
                labelContainer.style.whiteSpace = 'nowrap';
                labelContainer.style.zIndex = '30';
                labelContainer.style.pointerEvents = 'none';
                labelContainer.style.maxWidth = '200px';
                
                // Face thumbnail
                const faceThumbnail = document.createElement('img');
                faceThumbnail.className = 'face-thumbnail';
                faceThumbnail.style.width = '24px';
                faceThumbnail.style.height = '24px';
                faceThumbnail.style.borderRadius = '3px';
                faceThumbnail.style.marginRight = '6px';
                faceThumbnail.style.objectFit = 'cover';
                faceThumbnail.style.border = '1px solid rgba(255,255,255,0.3)';
                faceThumbnail.style.display = 'none';
                
                // Demographics info
                const infoText = document.createElement('div');
                infoText.className = 'person-info';
                infoText.style.display = 'flex';
                infoText.style.flexDirection = 'column';
                infoText.style.lineHeight = '1.2';
                
                const primaryInfo = document.createElement('div');
                primaryInfo.style.fontSize = '11px';
                primaryInfo.style.fontWeight = 'bold';
                
                const secondaryInfo = document.createElement('div');
                secondaryInfo.style.fontSize = '9px';
                secondaryInfo.style.opacity = '0.8';
                secondaryInfo.style.marginTop = '1px';
                
                const demographics = obj.demographics || {};
                const gender = demographics.gender && demographics.gender !== 'unknown' && demographics.gender !== 'analyzing...' ? demographics.gender : 'Unknown';
                const ageGroup = demographics.age_group && demographics.age_group !== 'unknown' && demographics.age_group !== 'analyzing...' ? demographics.age_group : 'Unknown';
                const emotion = demographics.emotion || 'neutral';
                const confidence = Math.round((demographics.confidence || 0.1) * 100);
                const analysisMethod = demographics.analysis_method || 'standard';
                
                primaryInfo.textContent = `ID: ${obj.id} | ${gender}, ${ageGroup}`;
                secondaryInfo.textContent = `${emotion} (${confidence}%) | ${analysisMethod}`;
                
                infoText.appendChild(primaryInfo);
                infoText.appendChild(secondaryInfo);
                
                labelContainer.appendChild(faceThumbnail);
                labelContainer.appendChild(infoText);
                element.appendChild(labelContainer);
                
                loadFaceThumbnail(obj.id, faceThumbnail);
            }
        } else if (existingLabelContainer) {
            existingLabelContainer.remove();
        }
    }
    
    // Cache for face thumbnails to avoid repeated requests
    const faceThumbnailCache = new Map();
    
    function loadFaceThumbnail(personId, imgElement) {
        // Check cache first
        if (faceThumbnailCache.has(personId)) {
            const cachedData = faceThumbnailCache.get(personId);
            if (cachedData.thumbnail) {
                imgElement.src = cachedData.thumbnail;
                imgElement.style.display = 'block';
            }
            return;
        }
        
        // Load from API
        fetch(`/api/face_thumbnail/${personId}?size=32x32`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.thumbnail) {
                    imgElement.src = data.thumbnail;
                    imgElement.style.display = 'block';
                    
                    // Cache the result
                    faceThumbnailCache.set(personId, {
                        thumbnail: data.thumbnail,
                        timestamp: Date.now()
                    });
                } else {
                    // Cache negative result to avoid repeated requests
                    faceThumbnailCache.set(personId, {
                        thumbnail: null,
                        timestamp: Date.now()
                    });
                }
            })
            .catch(error => {
                console.debug(`No face thumbnail for person ${personId}:`, error);
                // Cache negative result
                faceThumbnailCache.set(personId, {
                    thumbnail: null,
                    timestamp: Date.now()
                });
            });
    }
    
    // Clean up old cache entries every 5 minutes
    setInterval(() => {
        const now = Date.now();
        const maxAge = 5 * 60 * 1000; // 5 minutes
        
        for (const [personId, data] of faceThumbnailCache.entries()) {
            if (now - data.timestamp > maxAge) {
                faceThumbnailCache.delete(personId);
            }
        }
    }, 60000); // Run every minute
    
    function createPersonElement(obj, showBoxes, showLabels) {
        const personElement = document.createElement('div');
        personElement.className = 'person-element';
        personElement.style.position = 'absolute';
        personElement.style.left = `${obj.x}px`;
        personElement.style.top = `${obj.y}px`;
        personElement.style.width = `${obj.width}px`;
        personElement.style.height = `${obj.height}px`;
        personElement.style.boxSizing = 'border-box';
        personElement.style.pointerEvents = 'none';
        personElement.style.zIndex = '20';
        personElement.style.transition = 'opacity 0.3s ease-in, left 0.1s ease, top 0.1s ease, width 0.1s ease, height 0.1s ease';
        personElement.style.opacity = '0';
        
        // Store data in the element for use by overlays
        personElement.dataset.id = obj.id.toString();
        personElement.dataset.confidence = obj.confidence || 0.5;
        personElement.dataset.gender = obj.demographics?.gender || 'unknown';
        personElement.dataset.ageGroup = obj.demographics?.age_group || 'unknown';
        personElement.dataset.dwellTime = Math.round(Math.max(obj.dwell_time || 0, obj.zone_dwell_time || 0));
        personElement.dataset.zoneDwellTime = Math.round(obj.zone_dwell_time || obj.dwell_time || 0);
        personElement.dataset.zoneId = obj.zone_id || 0;
        personElement.dataset.zoneName = obj.zone_name || 'Outside';
        
        // Set border and background based on showBoxes
        if (showBoxes) {
            personElement.style.border = '2px solid #00ff00';
            personElement.style.background = 'rgba(0, 255, 0, 0.1)';
        } else {
            personElement.style.border = 'none';
            personElement.style.background = 'none';
        }
        
        // Add enhanced label with face thumbnail if needed
        if (showLabels) {
            const labelContainer = document.createElement('div');
            labelContainer.className = 'person-label-container';
            labelContainer.style.position = 'absolute';
            labelContainer.style.top = '-45px';
            labelContainer.style.left = '0';
            labelContainer.style.display = 'flex';
            labelContainer.style.alignItems = 'center';
            labelContainer.style.background = 'rgba(0, 0, 0, 0.85)';
            labelContainer.style.color = 'white';
            labelContainer.style.padding = '3px 6px';
            labelContainer.style.borderRadius = '5px';
            labelContainer.style.fontSize = '11px';
            labelContainer.style.fontWeight = 'bold';
            labelContainer.style.whiteSpace = 'nowrap';
            labelContainer.style.zIndex = '30';
            labelContainer.style.pointerEvents = 'none';
            labelContainer.style.maxWidth = '200px';
            
            // Face thumbnail (32x32)
            const faceThumbnail = document.createElement('img');
            faceThumbnail.className = 'face-thumbnail';
            faceThumbnail.style.width = '24px';
            faceThumbnail.style.height = '24px';
            faceThumbnail.style.borderRadius = '3px';
            faceThumbnail.style.marginRight = '6px';
            faceThumbnail.style.objectFit = 'cover';
            faceThumbnail.style.border = '1px solid rgba(255,255,255,0.3)';
            faceThumbnail.style.display = 'none'; // Initially hidden
            
            // Demographics info
            const infoText = document.createElement('div');
            infoText.className = 'person-info';
            infoText.style.display = 'flex';
            infoText.style.flexDirection = 'column';
            infoText.style.lineHeight = '1.2';
            
            // Primary info line
            const primaryInfo = document.createElement('div');
            primaryInfo.style.fontSize = '11px';
            primaryInfo.style.fontWeight = 'bold';
            
            // Secondary info line
            const secondaryInfo = document.createElement('div');
            secondaryInfo.style.fontSize = '9px';
            secondaryInfo.style.opacity = '0.8';
            secondaryInfo.style.marginTop = '1px';
            
            // Set initial content
            const demographics = obj.demographics || {};
            const gender = demographics.gender && demographics.gender !== 'unknown' && demographics.gender !== 'analyzing...' ? demographics.gender : 'Unknown';
            const ageGroup = demographics.age_group && demographics.age_group !== 'unknown' && demographics.age_group !== 'analyzing...' ? demographics.age_group : 'Unknown';
            const emotion = demographics.emotion || 'neutral';
            const confidence = Math.round((demographics.confidence || 0.1) * 100);
            const analysisMethod = demographics.analysis_method || 'standard';
            
            primaryInfo.textContent = `ID: ${obj.id} | ${gender}, ${ageGroup}`;
            secondaryInfo.textContent = `${emotion} (${confidence}%) | ${analysisMethod}`;
            
            infoText.appendChild(primaryInfo);
            infoText.appendChild(secondaryInfo);
            
            labelContainer.appendChild(faceThumbnail);
            labelContainer.appendChild(infoText);
            personElement.appendChild(labelContainer);
            
            loadFaceThumbnail(obj.id, faceThumbnail);
        }
        
        // Fade in new elements
        setTimeout(() => {
            personElement.style.opacity = '1';
        }, 10);
        
        return personElement;
    }
</script>

{% block extra_scripts %}
<script>
(async function(){
  const overlayContainer = document.getElementById('overlay-container');
  if (!overlayContainer) return;
  
  const zonesResp = await fetch('/api/zones');
  const json = await zonesResp.json();
  if(!json.success) return;
  
  window._zones = json.zones;
  const zones = json.zones;
  
  function createZoneOverlays() {
    // Remove existing zone overlays
    const existingOverlays = overlayContainer.querySelectorAll('.zone-overlay');
    existingOverlays.forEach(overlay => overlay.remove());
    
    // Find the analysis feed image
    const analysisImage = document.getElementById('analysis-feed-image');
    if (!analysisImage) return;
    
    // Get scaling factors - zones should be positioned directly on the image
    const imageWidth = analysisImage.clientWidth;
    const imageHeight = analysisImage.clientHeight;
    const scaleX = imageWidth / 1280;  // Use 1280x720 reference
    const scaleY = imageHeight / 720;
    
    zones.forEach((z, i) => {
      const div = document.createElement('div');
      div.className = 'zone-overlay';
      div.dataset.zoneName = z.name;
      div.dataset.zoneId = z.id;
      
      const color = ['#f44336','#2196f3','#4caf50','#ff9800','#9c27b0','#00bcd4','#e91e63'][i % 7];
      
      // Scale zone coordinates to image size
      const x1 = z.x1 * scaleX;
      const y1 = z.y1 * scaleY;
      const width = (z.x2 - z.x1) * scaleX;
      const height = (z.y2 - z.y1) * scaleY;
      
      div.style.cssText = `
        position: absolute;
        border: 3px dashed ${color};
        left: ${x1}px;
        top: ${y1}px;
        width: ${width}px;
        height: ${height}px;
        pointer-events: none;
        background: ${color}20;
        z-index: 15;
        font-weight: bold;
        color: ${color};
      `;
      
      // Add zone name label
      const label = document.createElement('div');
      label.style.cssText = `
        position: absolute;
        top: 5px;
        left: 5px;
        background: ${color};
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: bold;
      `;
      label.textContent = z.name;
      div.appendChild(label);
      
      overlayContainer.appendChild(div);
    });
  }
  
  // Create overlays when analysis image loads
  function setupImageObserver() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.id === 'analysis-feed-image') {
            console.log('Analysis image added to DOM, setting up zone overlays');
            node.addEventListener('load', () => {
              console.log('Analysis image loaded, creating zones');
              setTimeout(createZoneOverlays, 100);
            });
            node.addEventListener('loadeddata', () => {
              console.log('Analysis image data loaded, creating zones');
              setTimeout(createZoneOverlays, 100);
            });
            // Try to create overlays immediately if image is already loaded
            if (node.complete && node.naturalWidth > 0) {
              console.log('Analysis image already loaded, creating zones immediately');
              setTimeout(createZoneOverlays, 100);
            }
          }
        });
      });
    });
    
    observer.observe(overlayContainer.parentElement, { childList: true, subtree: true });
    
    // Check if image already exists
    const existingImage = document.getElementById('analysis-feed-image');
    if (existingImage) {
      console.log('Found existing analysis image, setting up zone overlays');
      existingImage.addEventListener('load', () => {
        console.log('Existing analysis image loaded, creating zones');
        setTimeout(createZoneOverlays, 100);
      });
      existingImage.addEventListener('loadeddata', () => {
        console.log('Existing analysis image data loaded, creating zones');
        setTimeout(createZoneOverlays, 100);
      });
      if (existingImage.complete && existingImage.naturalWidth > 0) {
        console.log('Existing analysis image already loaded, creating zones immediately');
        setTimeout(createZoneOverlays, 100);
      }
    }
  }
  
  // Window resize handler
  window.addEventListener('resize', () => {
    setTimeout(createZoneOverlays, 100);
  });
  
  setupImageObserver();
  
  // Socket.io integration for real-time zone updates
  if (typeof io !== 'undefined') {
    const socket = io();
    socket.on('zonesUpdated', async () => {
      const newZonesResp = await fetch('/api/zones');
      const newJson = await newZonesResp.json();
      if (newJson.success) {
        window._zones = newJson.zones;
        createZoneOverlays();
      }
    });
  }
})();
</script>
<style>
.zone-overlay {
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(1px);
  transition: background-color 0.3s ease;
}

.zone-overlay:hover {
  background: rgba(255, 255, 255, 0.15);
}

.zone-dwell-label {
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
  white-space: nowrap;
}
</style>
{% endblock %}

<script id="dwell-helper">
// Enhanced helper to find zone by point with detailed info
function getZoneNameByPoint(x, y) {
  if (!window._zones) return 'Outside';
  for (const z of window._zones) {
     if (x >= z.x1 && x <= z.x2 && y >= z.y1 && y <= z.y2) {
       return z.name;
     }
  }
  return 'Outside';
}

function getZoneByPoint(x, y) {
  if (!window._zones) return { id: 0, name: 'Outside' };
  for (const z of window._zones) {
     if (x >= z.x1 && x <= z.x2 && y >= z.y1 && y <= z.y2) {
       return { id: z.id, name: z.name, x1: z.x1, y1: z.y1, x2: z.x2, y2: z.y2 };
     }
  }
  return { id: 0, name: 'Outside' };
}

function getAllZones() {
  return window._zones || [];
}
</script>
{% endblock %}